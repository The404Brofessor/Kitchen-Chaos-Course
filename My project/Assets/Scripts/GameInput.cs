using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

public class GameInput : MonoBehaviour
{
    public event EventHandler OnInteractAction;
    public event EventHandler OnInteractAlternateAction;
    private PlayerInputActions playerInputActions;

    private void Awake() //We created this to utilize the auto-generated C# code from Unity to get the player input bindings and are now referencing for our inputs here to use it's code.
    {
       playerInputActions = new PlayerInputActions();
       playerInputActions.Player.Enable();
        #region
        //This code is taking the boolean "playerInputActions.Player.Enable()" and turning it "on/true".
        //once on, the above "class" of PlayerInputActions is allowed to listen to the "player" input. Otherwise it would ignore the input.
        //All of the script from PlayerInputActions class will then be active. As this code is a reference to the auto-generated script from unity. Created under the class PlayerInputActions
        #endregion

        playerInputActions.Player.Interact.performed += Interact_performed;
        playerInputActions.Player.InteractAlternate.performed += InteractAlternate_performed;
    }

    private void InteractAlternate_performed(UnityEngine.InputSystem.InputAction.CallbackContext obj)
    {
        OnInteractAlternateAction?.Invoke(this, EventArgs.Empty);
    }

    private void Interact_performed(UnityEngine.InputSystem.InputAction.CallbackContext obj)
    {
        #region eventinteract
        /*if (OnInteractAction != null)*/ //this essentially states that if their are no "listeners" the interact function be Null, but if it is NOT null, then proceed with function.
                                          //{ 
                                          //OnInteractAction(this, EventArgs.Empty);
                                          //}
        #endregion
        //Another form of code for this would be:
        OnInteractAction ?.Invoke (this, EventArgs.Empty); //"?" means that it will query or check (automatically from left side to right of "?") if OnInteractAction is null or not and then perform function
    }

    public Vector2 GetMovementVectorNormalized()
    {
        Vector2 inputVector = playerInputActions.Player.Move.ReadValue<Vector2>();
        #region Vectors
        //Vector2 inputVector = new Vector2(0, 0); //original code WE CREATED FOR MOVEMENT (BASIC)
        //We are going to modify the end of the above code with the PlayerInputActions, because we are now utilizing the autogenerated scripts in Unity to now impose the vector values based on that information and no longer need our "created" movement code.
        //this code will then have the sequence of movement we created with movement speed, rotation scripts to be applied

        //PlayerInputActions.PlayerActions.Move.ReadValue<Vector2>() ---> This code was made to draw from the auto-generated script in Unity for movementinputs from players that they had already made for us.
        #endregion
        #region basicinput notes
        //if (Input.GetKey(KeyCode.W))
        //    inputVector.y = +1;
        //if (Input.GetKey(KeyCode.S))
        //    inputVector.y = -1;
        //if (Input.GetKey(KeyCode.A))
        //    inputVector.x = -1;
        //if (Input.GetKey(KeyCode.D))
        //    inputVector.x = +1;
        #endregion

        inputVector = inputVector.normalized;
        return inputVector;
    }    

    //This entire above section was simplified into the code you see now, where we kept a complicated code created by ourselves and simplifying it into a bunch of code and class references in order to function on a more complex plane allowing the inclusion of gamepads and keyboards, etc.
    //all without the need to directly change each class from our player script if we were to ADD more than one player.
}
